<!DOCTYPE html><html>
<head>
<style>
tr.inf_down {
border-top: 1px solid #000;
}
tr.inf_down > td {
text-align: center;
padding: 0 10px;
}
tr.inf_up > td {
padding: 0px 10px;
text-align: center;
vertical-align: bottom;
}
tr.inf_up > td.inf_name {
vertical-align: middle;
font-size: 50%;
padding: 0px;
}
table.inf {
border-collapse: collapse;
padding: 10px;
}
tr.horizon > td {
padding: 0 10px;
}
ul.no_num {
list-style: none;
}
.box {
padding: 10px;
margin-bottom: 10px;
display: inline-block;
border: 1px solid #333;
}
.ch_title {
font-weight: bolder;
font-size: 130%;
}
.ch {
margin: 10px 0;
}
.ch_content {
}
.sec_header {
padding-bottom: 10px;
}
.sec_title {
font-weight: normal;
font-size: 120%;
}
.sec {
margin: 20px 0;
}
.sec_content {
margin-left: 20px;
}
</style>
<script type="text/javascript">
function onload(event) {
  var nodes = document.querySelectorAll("td.inf_name");
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var up = node.parentElement;
    var down = up && up.nextElementSibling;
    if (!down)
      continue;
    if (up.className != "inf_up" || down.className != "inf_down")
      continue;
    var up_height = up.clientHeight;
    var down_height = down.clientHeight;
    if (down_height < up_height)
      node.style.paddingTop = (up_height - down_height) + "px";
  }
};

window.addEventListener("load", onload);

</script><meta charset="UTF-8">
<title>tapl ch 16</title></head><body><ul><li><a href="#ch16">ch.16</a> 部分片付けのメタ理論<ul class="no_num"><li><a href="#sec16_0">16-0</a> この章でやりたいこと</li><li><a href="#sec16_1">16-1</a> アルゴリズム的部分型付け</li><li><a href="#sec16_2">16-2</a> アルゴリズム的型付け</li><li><a href="#sec16_3">16-3</a> 結びと交わり</li><li><a href="#sec16_4">16-4</a> アルゴリズム的型付けとBottom型</li></ul></li></ul><ul class="no_num"><li><div id="ch16" class="ch"><a href="#ch16">&nbsp;#&nbsp;</a><span class="ch_title"> chapter 16. 部分片付けのメタ理論</span><ul class="no_num"><li><div id="sec16_0" class="sec"><div class="sec_header"><a href="#sec16_0">&nbsp;◆&nbsp;</a> <span class="sec_title">section 16-0. この章でやりたいこと</span></div><div class="sec_content"><ul><li>前章での「部分型付けのある単純型付きラムダ計算」の定義は、<b>構文主導</b>ではない</li><li>構文主導とは、構文に基づいて、動作や意味が決まること</li><li>ボトムアップでは型検査アルゴリズムは得られない</li></ul><br><span class="box">★ 何が問題点か<br><br><ul><li>主な問題は、包摂規則(T-SUB)と推移律(S-TRANS)</li><li>単一のメタ変数 t を使って定義されているため、ほぼ任意の式に対して規則が適用可能になってしまう<br>=> どの規則を試すべきかが自明ではなく、アルゴリズムとしては不十分</li><li>さらに、S-TRANSには結論部に束縛されないメタ変数 U が前提部に出現する<br>=> 推測できる U の数は無限個あるため、このまま実装するには不適切</li></ul><br><table><tr class="horizon"><td><table class="inf"><tr class="inf_up"><td>Γ├ t : S</td><td>S &lt;: T</td><td class="inf_name" rowspan="2">T-SUB</td></tr><tr class="inf_down"><td colspan="2">Γ├ t : T</td></tr></table></td><td><table class="inf"><tr class="inf_up"><td>S &lt;: U</td><td>U &lt;: T</td><td class="inf_name" rowspan="2">S-TRANS</td></tr><tr class="inf_down"><td colspan="2">S &lt;: T</td></tr></table></td></tr></table></span><br>これらの問題は既存の規則を、構文主導的な推論規則の集合からなる以下の２つの関係で置き換えれば、解決できる。<br><ol><li>アルゴリズム的部分型関係</li><li>アルゴリズム的型付け関係</li></ol>また、書き換え前後の表現が一致することを証明することにより、この書き換えの正しさを示す。<br><br></div></div></li><li><div id="sec16_1" class="sec"><div class="sec_header"><a href="#sec16_1">&nbsp;◆&nbsp;</a> <span class="sec_title">section 16-1. アルゴリズム的部分型付け</span></div><div class="sec_content">例えば、t1 が T→U 型をもち、t2 が S 型を持つとして、関数適用 t1 t2 に出会ったとき、「SはTの部分型か」を判断するために、部分型検査器アルゴリズムが呼び出される。<br><br>アルゴリズム的関係には、規則S-TRANS, S-REFLがない。<br>S-TRANSをなくすには、まず深さ・幅・並び替えの部分型付けを一つにまとめる規則を追加する必要がある。<br><br><table class="inf"><tr class="inf_up"><td>{ li | i∈1..n } ⊆ { kj | j∈1..m }</td><td>kj = li ならば、Sj &lt;: Ti</td><td class="inf_name" rowspan="2">S-RCD</td></tr><tr class="inf_down"><td colspan="2">{ kj : Sj | j∈1..m } &lt;: { li : Ti | i∈1..n }</td></tr></table><br>&gt; つまり..<br>レコードA{ kj : Sj }、レコードB{ li : Ti } について<br><ul><li>レコードAのラベル名の集合が、レコードBのラベル名の集合を含んでる</li><li>それぞれの同じラベル名 kj, li について Sj &lt;: Ti</li></ul>ならば、レコードAはレコードBの部分型。<br><br>このS-RCDが、S-RCD-DEPTH, S-RCD-WIDTH, S-RCD-PERM（部分型付け規則の一部）を置き換えるものとして十分だということを、次の補題で証明してみよう。。<br><br><b id="16.1.1">補題 16.1.1</b><br><!-- もし、S-RCD-DEPTHとS-RCD-WIDTHとS-RCD-PERMの規則を含む（しかしS-RCDは含まない）部分型付け規則で  S <: T が導出できるならば、これは規則S-RCDを使っても（S-RCD-DEPTHとS-RCD-WIDTHとS-RCD-PERMの規則は使わないで）導出できる。また、逆も同様である。 --> S-RCD-DEPTH + S-RCD-WIDTH + S-RCD-PERM を含む部分型付け規則で S <: T を導出できる<br>⇄ S-RCD で S &lt;: T を導出できる<br><br><table class="inf"><tr class="inf_up"><td>各iに対して Si &lt;: Ti</td><td class="inf_name" rowspan="2">S-RCD-DEPTH</td></tr><tr class="inf_down"><td colspan="1">{ li : Si | i∈1..n } &lt;: { li : Ti | i∈1..n }</td></tr></table><table class="inf"><tr class="inf_up"><td>&nbsp;</td><td class="inf_name" rowspan="2">S-RCD-WIDTH</td></tr><tr class="inf_down"><td colspan="0">{ li : Ti | i∈1..n+k } &lt;: { li : Ti | i∈1..n }</td></tr></table><br><table class="inf"><tr class="inf_up"><td>{ kj : Sj | j∈1..n } は { li : Ti | i∈1..n } の並び替えである</td><td class="inf_name" rowspan="2">S-RCD-PERM</td></tr><tr class="inf_down"><td colspan="1">{ kj : Sj | j∈1..n } &lt;: { li : Ti | i∈1..n }</td></tr></table><br>⇅<br><table class="inf"><tr class="inf_up"><td>{ li | i∈1..n } ⊆ { kj | j∈1..m }</td><td>kj = li ならば、Sj &lt;: Ti</td><td class="inf_name" rowspan="2">S-RCD</td></tr><tr class="inf_down"><td colspan="2">{ kj : Sj | j∈1..m } &lt;: { li : Ti | i∈1..n }</td></tr></table><br><span class="box">証明）<br>導出に関する帰納法により、示す。<br><br>(→) S &lt;: T を導出する最後の規則で場合わけをする<br><ol><li>S-RCD-DEPTHの場合<br>S-RCD において、{ li } ≡ { kj } であるようなケース。{ li } ≡ { kj } より、前提部 { li } ⊆ { kj } を導くことができる。</li><li>S-RCD-WIDTHの場合<br>自明</li><li>S-RCD-PERMの場合<br>{ kj : Sj } が { li : Ti } の並び替えであるなら、前提部 { li } ⊆ { kj } を導くことができる。</li></ol><br>(←) S &lt;: T を導出する最後の規則が S-RCDであるとして、<br><ul><li>【{ li | i∈1..n } ⊆ { kj | j∈1..m } 】の部分<br>S-RCD-WIDTHに対応</li><li>【kj = li ならば、Sj <: Ti】の部分<br>ラベルの対応づけを行ってから型の対応関係を求めているので、S-RCD-PERM と S-RCD-DEPTH に対応</li></ul>の性質と、帰納法の仮定で示せれる。<br></span><br>この証明によって、S-RCDが、S-RCD-DEPTH, S-RCD-WIDTH, S-RCD-PERM を置き換えるものとして十分だということが示せた。<br>結果的に得られる型システムを、以下（<a href="#fig.16.1">図16-1</a>) のようにまとめることができる。<br><br><b id="fig.16.1">図16-1</b>: レコードのある部分型関係<br><span class="box"><table><tr class="horizon"><td><table class="inf"><tr class="inf_up"><td>&nbsp;</td><td class="inf_name" rowspan="2">S-REFL</td></tr><tr class="inf_down"><td colspan="0">S &lt;: S</td></tr></table></td><td><table class="inf"><tr class="inf_up"><td>S &lt;: U</td><td>U &lt;: T</td><td class="inf_name" rowspan="2">S-TRANS</td></tr><tr class="inf_down"><td colspan="2">S &lt;: T</td></tr></table></td></tr></table><table><tr class="horizon"><td><table class="inf"><tr class="inf_up"><td>&nbsp;</td><td class="inf_name" rowspan="2">S-TOP</td></tr><tr class="inf_down"><td colspan="0">S &lt;: TOP</td></tr></table></td><td><table class="inf"><tr class="inf_up"><td>T1 &lt;: S1</td><td>S2 &lt;: T2</td><td class="inf_name" rowspan="2">S-ARROW</td></tr><tr class="inf_down"><td colspan="2">S1 → S2 &lt;: T1 → T2</td></tr></table></td></tr></table><br><table class="inf"><tr class="inf_up"><td>{ li | i∈1..n } ⊆ { kj | j∈1..m }</td><td>kj = li ならば、Sj &lt;: Ti</td><td class="inf_name" rowspan="2">S-RCD</td></tr><tr class="inf_down"><td colspan="2">{ kj : Sj | j∈1..m } &lt;: { li : Ti | i∈1..n }</td></tr></table></span><br>では、次にS-TRANS, S-REFLが別のアルゴリズム的関係に置き換えることができることを示そう。<br><br><b id="16.1.2">補題 16.1.2</b><br>(1) すべての型Sについて、S &lt;: S はS-REFLを使わずに導出できる<br>(2) もし S &lt;: Tが導出可能ならば、 S &lt;: T は S-TRANSを使わずに導出できる<br><br><span class="box">証明）<br>(1) 型の大きさに関する帰納法で示す。<br><ul><li>S ≡ Top の場合<br>Top <: Top は、S-TOPにより示せる</li><li>S ≡ T1 → T2 の場合<br>T1 → T2 <: T1 → T2 は、S-ARROW により T1 <: T1, T2 <: T2 が成り立てばよいが、<br>これは帰納法の仮定により成立する。</li><li>S ≡ { ki : Si ( i∈1..n ) } の場合<br>補題16.1.1(→)より、S-RCD-DEPTHはS-RCDで代用することができる。<br>これを適用すると、各iに対して Si <: Si が成り立てばよいことになるが、これは帰納法の仮定により成り立つ。<br></li></ul><br>(2) 型の大きさに関する帰納法で示す。<br>S ≡ Top の場合<br><ul><li>T ≡ Top の場合<br>S-TOPにより成立。</li><li>T ≡ T1 → T2 の場合<br>そもそも導出不可能。(Topの定義より)</li><li>T ≡ { li : Si } の場合<br>そもそも導出不可能。(Topの定義より)</li></ul><br>S ≡ S1 → S2 の場合<br><ul><li>T ≡ Top の場合<br>S-TOPにより成立。</li><li>T ≡ T1 → T2 の場合<br>S-ARROWにより、T1 <: S1, S2 <: T2 が成り立てばよい。あとは帰納法の仮定。</li><li>T ≡ { li : Ti } の場合<br>そもそも導出不可能。※1</li></ul><br>S ≡ { kj : Sj } の場合<br><ul><li>T ≡ Top の場合<br>S-TOPにより成立。</li><li>T ≡ T1 → T2 の場合<br>そもそも導出不可能。※1</li><li>T ≡ { li : Ti } の場合<br>S <: T は導出可能なので、補題15.3.2(2)'より、<br>{ li } ⊆ { kj } かつ li = kj では Sj <: Ti である。つまり、S-RCDを適用すればおk。</li></ul><br>※1 補題15.3.2(2)を再証明することにより<br></span><br><br>よって、アルゴリズム的部分型付けは以下 (<a href="#fig.16.2">図16-2</a>) のようにまとめることができる。<br>※ 本章では、前章で扱った部分型付け判断式 S &lt;: T の代わりに、|→ S &lt;: T (「Sはアルゴリズム的にTの部分型になる」)という別の関係として表記する。<br><b id="fig.16.2">図16-2</b>: アルゴリズム的部分型付け<br><span class="box"><table class="inf"><tr class="inf_up"><td>&nbsp;</td><td class="inf_name" rowspan="2">SA-TOP</td></tr><tr class="inf_down"><td colspan="0">|→ S &lt;: TOP</td></tr></table><br><table class="inf"><tr class="inf_up"><td>|→ T1 &lt;: S1</td><td>|→ S2 &lt;: T2</td><td class="inf_name" rowspan="2">SA-ARROW</td></tr><tr class="inf_down"><td colspan="2">|→ S1 → S2 &lt;: T1 → T2</td></tr></table><br><table class="inf"><tr class="inf_up"><td>{ li | i∈1..n } ⊆ { kj | j∈1..m }</td><td>kj = li ならば、|→ Sj &lt;: Ti</td><td class="inf_name" rowspan="2">SA-RCD</td></tr><tr class="inf_down"><td colspan="2">|→ { kj : Sj | j∈1..m } &lt;: { li : Ti | i∈1..n }</td></tr></table></span><br><br><b id="16.1.3">演習 16.1.3</b><br>もし、型Boolを追加したら、これらの性質はどう変化するだろうか。<br><br><span class="box">証明）<br>型Boolを追加すると、型の構文規則が以下のようになる。<br><br><table><tr><td>T</td><td>::=</td><td>Top</td></tr><tr><td> </td><td>   </td><td>T → T</td></tr><tr><td> </td><td>   </td><td>{ li : Ti ( i∈1..n ) }</td></tr><tr><td> </td><td>   </td><td>&lt;b&gt;Bool&lt;/b&gt;</td></tr></table><br>ベースとなる型がひとつ増えるわけなので、以下のような規則を追加する必要がでてくる。<br><table class="inf"><tr class="inf_up"><td>&nbsp;</td><td class="inf_name" rowspan="2">SA-BOOL</td></tr><tr class="inf_down"><td colspan="0">|→ Bool &lt;: Bool</td></tr></table></span><br><br><b id="16.1.4">定義 16.1.4</b><br>アルゴリズム的部分型関係は、<a href="#fig.16.2">図16-2</a>の規則に閉じた最小の関係である。<br><br><span class="box"><ul><li><b>健全性</b> アルゴリズム的規則で導出できるすべての部分型付け判断式は、宣言的規則でも導出できる</li><li><b>完全性</b> 宣言的規則で導出できる全ての部分型付け判断式がアルゴリズム的規則でも導出できる</li></ul></span><br><br><b id="16.1.5">命題 16.1.5</b><br>[健全性と完全性] S &lt;: T のとき、かつそのときのみ |→ S &lt;: T<br><br><span class="box">証明）<br>どちらも導出に関する帰納法で示す。<br>(→)<br>S &lt;: T 導出木で、最後に適用した規則で場合分けする。<br><ul><li>S-REFL の場合<br>先の補題と導出の大きさに関する帰納法の仮定より。</li><li>S-TRANS の場合<br>先の補題と導出の大きさに関する帰納法の仮定より。</li><li>S-TOP の場合<br>SA-TOPを適用すればよい。</li><li>S-ARROW の場合<br>導出の大きさに関する帰納法の仮定より、|→ T1 <: S1, |→ S2 <: T2 が成り立つので、これに SA-ARROWを適用すればよい。</li><li>S-RCD の場合<br>略</li></ul><br>(←)<br>略<br></span><br><br>これで、アルゴリズム的部分型関係を検査するアルゴリズムが完成した＾＾<br>このアルゴリズムを擬似コードとして書くと以下のようになる。<br><br><span class="box"><table><tr><td>subtype(S, T)</td><td>=</td><td>if T = Top then true</td></tr><tr><td>             </td><td> </td><td>else if S = S1 → S2 and T = T1 → T2</td></tr><tr><td>             </td><td> </td><td>&amp;nbsp;&amp;nbsp;then subtype(T1, S1) ^ subtype(S2, T2)</td></tr><tr><td>             </td><td> </td><td>else if S = { kj : Sj | j∈1..m } and T = { li : Ti | i∈1..n }</td></tr><tr><td>             </td><td> </td><td>&amp;nbsp;&amp;nbsp;then { li | i∈1..m } ⊆ { kj | j∈1..m }</td></tr><tr><td>             </td><td> </td><td>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;^ すべてのiに対して、j∈1...mが存在し、kj = li かつ subtype(Sj, Ti)</td></tr><tr><td>             </td><td> </td><td>else false</td></tr></table></span><br>最後に、この関係が<b>全域的</b>、つまり、この再帰関数subtypeが任意の入力に対して有限時間内に結果を返すことを検証する必要がある。<br><br><b id="16.1.6">命題 16.1.6</b><br>[停止性] もし |→ S &lt;: T が導出可能ならば、subtype(S, T)は true を返す。そうでないなら、false を返す。<br><br><span class="box">証明）<br>再帰時の引数の大きさの和は、入力S, Tの大きさの和より真に小さいので、ちゃんと止まる。<br></span><br><br>【「はじめっから、アルゴリズム的定義でやれば良いのでは？」と思った人へ】<br>まあその通りなのだが、型付け関係の正当性を示すためには、「部分型付けが反射的・推移的である」ことを知る必要があるので、どっちの定義を先に持ってきても作業量はさほど変わらないよ。<br><br></div></div></li><li><div id="sec16_2" class="sec"><div class="sec_header"><a href="#sec16_2">&nbsp;◆&nbsp;</a> <span class="sec_title">section 16-2. アルゴリズム的型付け</span></div><div class="sec_content">部分型関係をアルゴリズム的にした今、型付け関係もアルゴリズム的にする必要がある。現在、T-SUBだけが構文主導でない型付け規則であるが、これをなくすことを考えてみよう。<br><br><table class="inf"><tr class="inf_up"><td>Γ├ t : S</td><td>S &lt;: T</td><td class="inf_name" rowspan="2">T-SUB</td></tr><tr class="inf_down"><td colspan="2">Γ├ t : T</td></tr></table><br>簡単にT-SUBを消すことはできない。T-SUBを使う目的は「関数によって期待される型と、引数の実際の型との隔たりを埋めること」である。下の例は、T-SUBが型付けにおいて重要な役割を果たす<b>唯一の</b>状況である。<br><br>(λr:{ x:Nat }. r.x) { x=0, y=0 }<br><br>他の全ての場合では、部分型付け判断式を別の導出によって証明することができる。T-SUBを木の根に向かって動かし「後回し」にする導出である。このテクニックをここで少し紹介する。<br><h3>略</h3><br><br><b id="16.2.1">演習 16.2.1</b><br>この実験を仕上げるため、T-RCD または T-PROJ の前で規則T-SUBが使われているような導出において、どのように同様の再配置を実行すればよいかを示せ。<br><br><span class="box">証明）<br>省略<br></span><br>さて、このことからT-SUBが必要となる場所はただ一つ、関数適用だけになった。この場合にT-SUBなしで対応するために、関数適用の規則を少し強力なもので置き換えてみよう。<br><br><table class="inf"><tr class="inf_up"><td>Γ├ t1 : T11 → T12</td><td>Γ├ t2: T2</td><td>T2 &lt;: T11</td><td class="inf_name" rowspan="2"></td></tr><tr class="inf_down"><td colspan="3">Γ├ t1 t2 : T12</td></tr></table><br>↑前提部にT-SUBのインスタンスの一つ「T2 &lt;: T11」を合体させた！これにより、全ての導出がT-SUBを使わない形になり、元の型システムと同じ項の集まりに型を割り当てる【構文主導的な型付け規則の集合】が得られた（＾ー＾）b<br><br>よって、アルゴリズム的型付けは以下 (<a href="#fig.16.3">図16-3</a>) のようにまとめることができる。<br>※アルゴリズム的部分型付け規則と同様、宣言的関係と区別するため、Γ|→ t : T と書くことにする。<br><b id="fig.16.3">図16-3</b>: アルゴリズム的型付け<br><span class="box"><table><tr class="horizon"><td><table class="inf"><tr class="inf_up"><td>x : T ∈ Γ</td><td class="inf_name" rowspan="2">TA-VAR</td></tr><tr class="inf_down"><td colspan="1">Γ|→ x : T</td></tr></table></td><td><table class="inf"><tr class="inf_up"><td>Γ、x : T1 |→ t2 : T2</td><td class="inf_name" rowspan="2">TA-ABS</td></tr><tr class="inf_down"><td colspan="1">Γ|→ λx:T1. t2 : T1 → T2</td></tr></table></td></tr></table><br><table class="inf"><tr class="inf_up"><td>Γ|→ t1 : T1</td><td>Γ|→ t2: T2</td><td>T1 = T11 → T12</td><td>|→ T2 &lt;: T11</td><td class="inf_name" rowspan="2">TA-APP</td></tr><tr class="inf_down"><td colspan="4">Γ|→ t1 t2 : T12</td></tr></table><br><table class="inf"><tr class="inf_up"><td>各iに対して、Γ|→ ti : Ti</td><td class="inf_name" rowspan="2">TA-RCD</td></tr><tr class="inf_down"><td colspan="1">Γ|→ { l1=t1 ... ln=tn } : { l1 : T1 ... ln : Tn }</td></tr></table><br><table class="inf"><tr class="inf_up"><td>t1 : R1</td><td>R1 = { l1 : T1 ... ln : Tn }</td><td class="inf_name" rowspan="2">TA-PROJ</td></tr><tr class="inf_down"><td colspan="2">Γ|→ t1.li : Ti</td></tr></table><br></span><br><br><b id="16.2.2">定義 16.2.2</b><br>アルゴリズム的型付け関係は<a href="#fig.16.3">図16-3</a>の規則について閉じた最小の関係である。<br><br><b id="16.2.3">演習 16.2.3</b><br>ある項にアルゴリズム的型付け規則で割り当てられる型が評価によって、減少しうることを示せ。これは、ある２つの項 s と t で、アルゴリズム的型付けで S と T に型付けされ、s →* t かつ T &lt;: S だが、S !&lt;: T となるようなものを見つけることで示せ。<br><br><span class="box">証明）<br><ul><li>しらん</li></ul></span><br><br>部分型付けのときと同様に、アルゴリズム的型付け関係が、元の宣言的な規則について、健全かつ完全であることを証明していく。<br><br><b  id="16.2.4">定理 16.2.4</b><br>[健全性] Γ|→ t : T ならば Γ├ t : T となる。<br>アルゴリズム的型付け導出に関する単純な帰納法により、示せ。<br><br><span class="box">証明）<br>省略<br></span><br><br><b id="16.2.5">定理 16.2.5</b><br>[完全性、最小型付け] もし Γ├ t : T ならば、ある S &lt;: T が存在して、Γ|→ t : S<br><br><span class="box">証明）<br>宣言的な型付け導出に関する帰納法により証明。<br><ul><li>T-VAR の場合 t = x <br>このとき、Γ(x) = T これに TA-VARを適用すれば、Γ|→ x : T<br><br></li><li>T-ABS の場合 t =  λx:T1. t2<br>このとき、Γ, x : T1├ t2 : T2 かつ T = T1 → T2<br>帰納法の仮定より、ある S2 <: T2 に対し、Γ, x : T1├ t2 : S2<br>これにTA-ABSを適用すると、Γ├t : T1 → S2<br>S-ARROWより、T1 → S2 <: T1 → T2<br><br></li><li>T-APP の場合 t = t1 t2<br>このとき、Γ├t1 : T11 → T12 かつ Γ├t2 : T11 かつ T = T12<br>帰納法の仮定より、ある S1 <: T11 → T12 に対し、Γ |→ t1 : S1 であり、ある S2 <: T11 に対し、Γ├t2 : S2 である。<br>補題15.3.2より、S1 は T11 <: S11 かつ S12 <: T12 なる S11 と S12 に対して S11 →S12 という形をもつ。<br>S-TRANSより、S2 <: S11。アルゴリズム的部分型付けの完全性より、|→ S2 <: S11<br>さらに TA-APP より、Γ├t1 t2 : S12<br><br></li><li>T-RCD の場合 t = { li=ti }<br>このとき、各iに対し Γ├ti : Ti かつ T = { li:Ti }。あとは帰納法の仮定とTA-RCDより。<br><br></li><li>T-APROJ の場合 t = t1.lj<br>このとき、Γ├ t1 : { li:Ti } かつ T = Tj。あとは略<br><br></li><li>T-SUB の場合 前提条件より、t : S' かつ S' <: T<br>帰納法の仮定より、ある S <: S' が存在して、Γ├ t : S であるが、このときS-TRANSより、S <: T。</li></ul></span><br><br><b id="16.2.6">定理 16.2.6</b><br>もし部分型付け規則 S-ARROW をなくし、それ以外の宣言的な部分型付け規則、および型付け規則はそのままにした場合、この体型は最小型付けの性質を持つか。もしそうならば、それを証明せよ。そうでないなら、最小型を持たない、型付け可能な項の例を示せ。<br><br><span class="box">証明）<br>項 λx: {a : Nat}. x は宣言的な規則の下では、<br><ul><li>{a:Nat} → {a:Nat}</li><li>{a:Nat} → Top</li></ul>のどちらの型ももつ。<br><br>しかし、S-ARROWをなくすと、これらの型は互いの部分型にならない。<br>つまり、下式を証明できなくなる。<br><br>{a:Nat} → {a:Nat} &lt;: {a:Nat} → Top<br></span><br><br></div></div></li><li><div id="sec16_3" class="sec"><div class="sec_header"><a href="#sec16_3">&nbsp;◆&nbsp;</a> <span class="sec_title">section 16-3. 結びと交わり</span></div><div class="sec_content">分岐があると、部分型の扱いが少しややこしくなる。なぜなら、どの場合に分岐しても必ず部分的に同じ型でなくてはいけなくなるから。<br>例えば、以下のような導出規則T-IFがあるとする。<br><br><table class="inf"><tr class="inf_up"><td>Γ├ t1 : Bool</td><td>Γ├ t2 : T</td><td>Γ├ t3 : T</td><td class="inf_name" rowspan="2">T-IF</td></tr><tr class="inf_down"><td colspan="3">Γ├ if t1 then t2 else t3 : T</td></tr></table><br>このとき、if true then { x=true, y=false} else { x=false, z=true } は { x: Bool } という型をもつ。<br>なぜなら、<br><ul><li>then節は最小型 { x: Bool, y: Bool } を持ち、これはT-SUBによって { x: Bool } に昇格できる</li><li>else節の型 { x: Bool, z: Bool } も { x: Bool } に昇格できる</li><li>よって、{ x: Bool, y: Bool } と { x: Bool, z: Bool } の両方の上位型である任意の型をもつ</li><li>この中で最小の型は { x: Bool }　である</li></ul>ためである。<br><br>この型は分岐の型についての<b>結び</b>としばしば呼ばれる。これは半順序における２つの要素の結びに相当するからである。<br><br><b id="16.3.1">定義 16.3.1</b><br><ul><li>[<b>結び</b>] 型の二つ組S, Tに対して、ある型 J が S と T の<b>結び</b>であるとは、S <: J かつ T <: J かつ 任意の型 U に対して、S <: U かつ T <: U ならば J <: U となること。</li><li>[<b>交わり</b>] 型の二つ組S, Tに対して、ある型 M が S と T の<b>交わり</b>であるとは、M <: S かつ M <: T かつ、任意の型 L に対して、L <: S かつ L <: T ならば、L <: M となること。</li><li>[<b>下に有界</b>] 型の二つ組S, Tについて、ある型 L が存在して、L <: S かつ L <: T となるとき、<b>下に有界である</b>という。</li><li>[<b>有界な交わり</b>] 下に有界である全ての S と T について、S と T の交わり M が存在するような部分型関係は、<b>有界な交わりを持つ</b>という。</li></ul><br><img src="./graph.png" width="600px"><br><br>注釈<br><ul><li>結びの関係を、S v T = J と表記する。</li><li>交わりの関係を、S ^ T = M と表記する。</li></ul><br>この節で考える部分型関係は結び (最大でTop) を持つが交わりを持たない。<br>例えば、型 {} と Top → Top は共通の部分型を全く持たないため、最大の共通の部分型は存在しない。<br><br>結びや交わりは唯一である必要はない。<br>例えば、{ x : Top, y : Top, z : Top } と { x : Top, y : Top, w : Top } は、結びとして、{ x : Top, y : Top } と { y : Top, x : Top } を持つ。<br><br>同じ型の二つ組に対する、二つの異なる結び J1, J2（または交わり）は必ず、お互いの部分型になる。<br><br><b id="16.3.2">命題 16.3.2</b><br>(1) すべての型の二つ組S, Tについて、ある型Jが存在して、S v T = J<br>(2) 共通の部分型を持つ、すべての型の二つ組S, Tについて、ある型Mが存在して、S ^ T = M<br><br><span class="box">証明）<br>どちらの場合も、それを求めるアルゴリズムを示せればよい。<br><table><tr><td>S v T = </td><td> Bool               </td><td> S = T = Bool の場合</td></tr><tr><td>        </td><td> M1 → M2            </td><td> S = S1 → S2,</td></tr><tr><td>        </td><td>                    </td><td> T = T1 → T2,</td></tr><tr><td>        </td><td>                    </td><td> S1 ^ T1 = M1,</td></tr><tr><td>        </td><td>                    </td><td> S2 v T2 = J2 の場合</td></tr><tr><td>        </td><td> { jl:Jl | l∈1..q }</td><td> S = { kj:Sj | j∈1..m }</td></tr><tr><td>        </td><td>                    </td><td> T = { li:Ti | i∈1..n }</td></tr><tr><td>        </td><td>                    </td><td> { jl | l∈1..q } = { kj | j∈1..m } ∩ { li | i∈1..n }</td></tr><tr><td>        </td><td>                    </td><td> 各 jl = kj = li に対して Sj v Ti = Jl の場合</td></tr><tr><td>        </td><td> Top                </td><td> それ以外</td></tr></table><table><tr><td>S ^ T = </td><td>省略</td></tr></table></span><br><br><b id="16.3.3">演習 16.3.3</b><br>if true then false else {} の最小型は何か。これは我々の求めているものか。<br><br><span class="box">証明）<br><ul><li>then節は最小型として Bool を持つ</li><li>else節は最小型として {} を持つ</li><li>両節の上位型の中で最小の型はTop</li><li>よって、全体として Top 型になる</li></ul>任意の型Sに対して S &lt;: TOP が成り立つ(SA-TOP)ので、あまり情報として意味がない。<br></span><br><br><b id="16.3.4">演習 16.3.4</b><br>結びと交わりを計算するアルゴリズムを、15.5節で記述されたような参照を持つ手続き型言語へ拡張することは簡単か。非変なRefを共変なSourceと反変なSinkに詳細化した15.5節での参照の扱いについてはどうか。<br><table class="inf"><tr class="inf_up"><td>S1 &lt;: T1</td><td class="inf_name" rowspan="2">S-SOURCE</td></tr><tr class="inf_down"><td colspan="1">Source S1 &lt;: Source T1</td></tr></table><table class="inf"><tr class="inf_up"><td>T1 &lt;: S1</td><td class="inf_name" rowspan="2">S-SINK</td></tr><tr class="inf_down"><td colspan="1">Sink S1 &lt;: Sink T1</td></tr></table><br><span class="box">証明）<br>Ref の追加に関しては、アルゴリズムを拡張するだけでよい(省略)。<br>しかし、Source, Sink 構築子に詳細化すると、部分型関係が結び・交わりを持たなくなる問題が発生する。<br>例えば、<br><ul><li>Ref { a:Nat b:Bool } &lt;: Source { a: Nat }</li><li>Ref { a:Nat } &lt;: Sink { a:Nat b:Bool }</li></ul>であるが、これらは共通の下界を持たない。(Refは非変であるため)<br>この問題を回避するためにはSource, Sinkを両方でなく、どちらか一方だけを導入すること。これらの具体的な実装については、後の章でやる予定。<br></span><br><br></div></div></li><li><div id="sec16_4" class="sec"><div class="sec_header"><a href="#sec16_4">&nbsp;◆&nbsp;</a> <span class="sec_title">section 16-4. アルゴリズム的型付けとBottom型</span></div><div class="sec_content">もし部分型関係に最小型Bot(15.4節)を加える場合、拡張が必要。<br>まず、アルゴリズム的部分関係に一つの公理を追加する。<br><table class="inf"><tr class="inf_up"><td>&nbsp;</td><td class="inf_name" rowspan="2">SA-BOT</td></tr><tr class="inf_down"><td colspan="0">|→ Bot &lt;: T</td></tr></table><br>次に、アルゴリズム的型付け関係には、二つの規則を追加する。<br><br><table class="inf"><tr class="inf_up"><td>Γ|→ t1 : T1</td><td>T1 = Bot</td><td>Γ|→ t2 : T2</td><td class="inf_name" rowspan="2">TA-APPBOT</td></tr><tr class="inf_down"><td colspan="3">Γ|→ t1 t2 : Bot</td></tr></table><table class="inf"><tr class="inf_up"><td>Γ|→ t1 : R1</td><td>R1 = Bot</td><td class="inf_name" rowspan="2">TA-PROJBOT</td></tr><tr class="inf_down"><td colspan="2">Γ|→ t1.li : Bot</td></tr></table><br>Botは任意の他の型を持つことができる。<br><br>Bot型のものには無条件に任意の型の引数を関数適用できる。<br>これはT-SUBを使って、Botをどんな関数型にもできるため。射影(TA-PROJBOT)に関しても同様。<br><br><b id="16.4.1">演習 16.4.1</b><br>この言語が条件式も持っていたとする。このとき、ifについてのアルゴリズム的型付け規則を追加する必要はあるか。<br><br><span class="box">証明）<br>追加の必要あり。<br><table class="inf"><tr class="inf_up"><td>Γ|→ t1 : T1</td><td>T1 = Bot</td><td>Γ|→ t2 : T2</td><td>Γ|→ t3 : T3</td><td>T2 v T3 = T</td><td class="inf_name" rowspan="2">TA-IF</td></tr><tr class="inf_down"><td colspan="5">Γ|→ if t1 then t2 else t3 : T</td></tr></table>など。<br>Bot は空なため（実際にBot型となるような項は存在しない）、t1 の評価は結果を返すことはない。<br></span><br><br>28.8節で、Botが有界量化と合わさったときにより複雑になるが、今節でのBotの追加は容易い。<br></div></div></li></ul></div></li></ul></body></html>
