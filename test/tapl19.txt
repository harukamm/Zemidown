font-size 10

#

:ch 19
Featherweight Java

:sec 0
この章でやりたいこと

:s

前章では、オブジェクト指向プログラミングの主要な機能を、部分型付けとレコード、参照を持つラムダ計算を用いてモデル化した。
本章では、別アプローチとして組み込みのオブジェクトを定義する。
:e

:sec 1
導入

:s

プログラミング言語のような人工物を形式的にモデル化することによる利点
:s-item
-設計の正確な説明となる
-ある性質を記述・証明できるようになる
:e-item

しかし、モデル化には「完全さ」と「コンパクトさ」の間で葛藤がある。

\<b>Featherweight Java (FJ)</b>は、Javaの型システムをモデル化するために最低限必要な計算体系を定義したものである。
FJ は、執拗といえるくらいに「完全さ」より「コンパクトさ」を重視している。（項には５つの形式しかなく、破壊的代入さえも省略されている。）

他の性質
:s-item
-全てのFJプログラムは、そのままJavaプログラムとして実行可能であり、直接的な対応関係があるといえる。
-FJ の主な応用は、Javaの拡張機能をモデル化すること。「コンパクトさ」のおかげで、拡張の本質的な側面に集中して考えることができる。
:e-item
:e

:sec 2
概観

:s

以下に、FJの典型的なクラス定義を示す。
:s-box
class A extends Object { A() { super(); } }

class B extends Object { B() { super(); } }

class Pair extends Object {
\&nbsp;&nbsp;Object fst;
\&nbsp;&nbsp;Object snd;
\&nbsp;&nbsp;
\&nbsp;&nbsp;Pair(Object fst, Object snd) {
\&nbsp;&nbsp;&nbsp;&nbsp;super();
\&nbsp;&nbsp;&nbsp;&nbsp;this.fst = fst;
\&nbsp;&nbsp;&nbsp;&nbsp;this.snd = snd;
\&nbsp;&nbsp;}
\&nbsp;&nbsp;Pair setfst(Object newfst) {
\&nbsp;&nbsp;&nbsp;&nbsp;return new Pair(newfst, this.snd);
\&nbsp;&nbsp;}
}
:e-box

文法規則は後の節で示されるが、レシーバが this の場合であっても省略禁止などの制約がいくつかある。
破壊的代入が禁止されているため、コンストラクタは代入'=' が現れる唯一の場所である。

項の形は５つしかない。
:s-item
-\オブジェクトコンストラクタ<br>例：new A(), new B(), new Pair(...)
-\メソッド呼び出し<br>例：Receiver.setfst(...)
-\フィールド参照<br>例：this.snd
-\変数<br>例：newfst, <b>this</b>
-\キャスト<br>例：X = new Pair(new A(), new B()), Y = new A() としたとき<br>((Pair)(new Pair(X, Y).fst).snd)<br>fstフィールドはObjectと定義されているので、キャストが必要。
:e-item

それぞれラムダ計算と対応づけることができるが、いくつか重要な違いがあり、その違いを実現するために別の処理が必要である。

:s-item
-\メソッドオーバーライド<br>どのメソッドを呼び出すべきかを、レシーバのクラスが決定する
-\selfを介した「オープンな再帰」<br>メソッドを呼び出す前にthisにレシーバを代入
-\キャスト<br>対象のオブジェクトの実行時のクラス が キャスト先のクラス のサブクラスであるかを確認<br>(1) サブクラスならば、キャストが取り除かれる<br>(2) そうでないなら、計算は<b>行き詰まり状態</b>になる。これは実行時エラーをさす。
:e-item

計算を行き詰まり状態にしてしまう方法は３つある。
:s-item
-クラスに宣言されていないフィールドを参照する
-クラスに宣言されていないメソッドを呼び出す
-オブジェクトの実行時のクラスのスーパークラス以外の何かにキャストする
:e-item

正しく型付けを行えば、最初の２つが起きないことは証明することができる。
また、プログラムがダウンキャストを含まず、かつ正しく型付けされているときは、３つ目も起きないことを証明できる。

ここでは、標準的な値呼び評価を用いる。
:e

:sec 3
名前的型システムと構造的型システム

:s

FJ と、型付きラムダ計算との基礎的な様式の違いについて述べる。
\この違いとは、<b>型名</b>の立ち位置に関することである。

本章以前では、可読性のため、長く複合的な型に短い名前をしばしば定義した。

NatPair = { fst:Nat, snd:Nat };

このような定義は表面的なものである。
名前はただの省略形で、この２つはすべての文脈で相互に置き換え可能である。

一方、Javaでは、型定義がずっと重要な役割を果たす。

\Java プログラムで用いられる複合的な型は<b>全て</b>名前を持つ。
ローカル変数、フィールド、メソッドの仮引数を宣言するときは、必ず名前を与える必要がある。
その場面で、{ fst:Nat, snd: Nat }のような「裸」の型を書くことはできない。

これらの型名は、Java の部分型関係において、重要な役割を果たす。
新しいクラスを定義するには新しい名前を導入する必要があるし、extends するクラス名はプログラマが明示的に宣言する。
もしある名前が他の名前の部分型になると宣言されていないなら、それは部分型ではない。

:s-item
-\Java のように、名前が重要で、部分型関係が明示的に宣言される型システムを<b>名前的</b>という。
-\名前が本質的でなく、部分型関係が型の構造上で定義される型システムを<b>構造的</b>という。
:e-item

名前的型システムが持つ利点
:s-item
-\実行時の各オブジェクトに「型を表すデータ」へのタグがついており、その型のデータは、直接の上位型へのポインタを保持している。 <br>→ 実行時型検査（instanceOf 検査、ダウンキャスト操作など）に有用<br><br>
-\List の定義の中で List を参照するのは他の型を参照するのと同じ。型名の集合は最初から与えられているものとみなす。<br>→ 「どちらが先に定義されたか」という問題が起きず、再帰型 を直感的に説明できる<br><br>
-\プログラマにextends, implements を明示的に宣言させる<br>→ ある型が他の部分型かどうかを自明に検査できる<br><br>
-\「偽の包摂関係」を防止できる
:e-item

一方で、プログラミング言語の研究論文のほとんどは、構造的型システムに関心がある。

理由（１）
少なくとも再帰型がなければ、構造的型システムのほうが少し整然・洗練されている。
構造的なほうでは、型式は独立したものとなり、型式の意味を理解するために必要な情報が備わっている。
対して、名前的型システムでは、型名とその定義についてのテーブルを常に扱う必要があり、そのせいで定義も証明もより冗長となってしまいがち。

理由（２）
研究論文が目を向けがちな、より発展的な機能（パラメータ多相、抽象データ型、ファンクタなどの型抽象に関する強力な仕組み）が、構造的型システムと相性が良い。
対して、そういう機能は、名前的型システムとはあまり相性がよくない。例えば、List(T)のような型は複合的な型であり、原始的な名前として扱うことができない。List(T)の挙動を見るには、Listの定義を参照する必要がある。
:e

:sec 4
定義

:s

注釈
:s-item
-メタ変数 A, B, C, D, E はクラス名
-f, g はフィールド名
-m はメソッド名
-x は仮引数名
-s, t は項
-u, v は値
:e-item

:s-box
★  構文
:s-item
-<f> は f1, ..., fn の略記
-<C f> は C1 f1, ... , Cn fn の略記
-<C f;> は C1 f1; ... Cn fn; の略記
-this.<f> = <f> は this.f1 = f1; ... this.fn = fn; の略記
-<M> は M1 ... Mn の略記
-宣言された名前は、重複してはいけない
:e-item

:s-table
|CL |::=|class C extends C { <C f;> K <M> }      |                  |クラス宣言          |
|K  |::=|C(<C f>) { super(<f>); this.<f> = <f>; }|                  |コンストラクタ宣言  |
|M  |::=|C m(<C x>) { return t; }                |                  |メソッド宣言        |
|t  |::=|x                                       |変数              |項                  |
|   |   |t.f                                     |フィールドアクセス|                    |
|   |   |t.m(<t>)                                |メソッド呼び出し  |                    |
|   |   |new C(<t>)                              |オブジェクト生成  |                    |
|   |   |(C) t                                   |キャスト          |                    |
||||||
|v  |::=|new C(<v>)                              |オブジェクト生成  |値                  |
:e-table

★ 部分型付け
:s-horizon
:inf(C <: C, [])
:inf(C <: E, [C <: D, D <: E])
:inf(C <: D, [CT(C) = class C extends D { .. } ])
:e-horizon
:e-box

※ コンストラクタ引数は、インスタンス変数とちょうど同じ数だけでなくてはならない。
※ 完全な Java では、スーパークラスのコンストラクタが引数を受け取る場合のみ、スーパークラスのコンストラクタの呼び出しが必須

クラス表 CT は、クラス名 C から クラス宣言 CL への写像である。
クラス表は、以下の健全性条件を満たすものと仮定する。
\<h>略</h>

全てのクラスは extends で宣言されたスーパークラスを持つ。
ここでは、Object を特別なクラスとして扱い、クラス表の中に定義が現れない特別なクラス名とする。

\<b id="19.4.1">演習 19.4.1. </b>
\<h>略</h>

\<b>補助的な定義</b>

型付け規則と評価規則のために、補助的な定義をいくつか定める必要がある。

:s-box
:s-item
-クラス C のフィールドの列を fields(C) と書く。スーパークラスで宣言されているフィールドを含む。
-クラス C のメソッド m の型を、mtype(m, C) と書く。
-クラス C のメソッド m の本体を mbody(m, C) と書く。
-述語 override(m, D, <C> → C0) は、引数の型が<C>で、結果の型が C0 であるメソッド m を D のサブクラスに定義可能かどうかを判断する。
:e-item

★ フィールドの探索
:s-horizon
:inf(fields(Object) = φ, [])
:inf(fields(C) = <D g> + <C f>, [CT(C) = class C extends D {<C f;> K <M>}, fields(D) = <D g>])
:e-horizon

★ メソッドの型の探索

:inf(mtype(m\, C) = <B> → B, [CT(C) = class C extends D { <C f;> K <M> }, B m (<B x>) { return t; } ∈ <M>])
:inf(mtype(m\, C) = mtype(m\, D), [CT(C) = class C extends D { <C f;> K <M> }, m は <M> の中で定義されていない])

★ メソッド本体の探索

:inf(mybody(m\, C) = (<x>\, t), [CT(C) = class C extends D { <C f;> K <M> }, B m (<B x>) { return t; } ∈ <M>])
:inf(mbody(m\, C) = mbody(m\, D), [CT(C) = class C extends D { <C f;> K <M> }, m は <M> の中で定義されていない])

★ メソッドの正当なオーバーライド

:inf(override(m\, D\, <C> → C0), [mtype(m\, D) = <D> → D0 ならば <C> = <D> かつ C0 = D0])
:e-box

\<b>評価</b>

標準的な値呼び操作的意味論を用いる。
評価器の正常終了の結果となりうる値は、new C(<v>) という形の、完全に引数の評価されたオブジェクト生成の項である。

:s-box
:s-horizon
:inf-E-ProjNew((new C(<v>)).fi → vi, [fields(C) = <C f>])
:inf-InvkNew((new C(<v>)).m(<u>), [mbody(m\, C) = (<x>\, t0)])
:inf-E-CaseNew((D)(new (<b>)) → new C(<v>), [C <: D])
:e-horizon
:inf-E-Field(t0.f → t0'.f,[t0 → t0'])
:inf-E-InvkRecv(t0.m(<t>) → t0'.m(<t>), [t0 → t0'])
:inf-E-InvkArg(v0.m(<v>\, ti\, <t>) → v0'.m(<v>\, ti'\, <t>), [ti → ti'])
:inf-E-NewArg(new C(<v>\, ti\, <t>) → new C(<v>\, ti'\, <t>), [ti → ti'])
:inf-E-Cast((C)t0 → (C)t0', [t0 → t0'])
:e-box

\<b>型付け</b>

「愚かな」キャストの導入 (C) D
:s-item
-アップキャスト：D <: C の場合　例：(Object) (new A())
-ダウンキャスト：C <: D の場合　例：(A) (new Object())
-愚かなキャスト：D と C が無関係の場合
:e-item

Java コンパイラは愚かなキャストを含む項を、正しく型付けされないもとして拒否する。
しかし FJ では、小ステップ意味論の型保存定理として型安全性を定式化する以上、愚かなキャストを認める必要がある。これは、愚かなキャストを含まない項が愚かなキャストを含む項に簡約されることがあるからである。

(A)(Object)new B() → (A)new B()

このため、前提部に愚かなキャストの性質を含めた規則 T-SCast を定義している。
FJ の型付けが正しい Java の型付けに対応するのは、この規則を除いたときのみである。

M OK in C という形式は、「メソッド宣言 M は、それが C の中にあるなら正しい」と読む。メソッド本体の中に現れ売る自由変数は、メソッドの仮引数と this のみである。

CL OK という形式は、「クラス宣言 CL は正しい形式をしている」と読む。

:s-box
:inf-T-Var(Γ├ x : C, [x : C ∈ Γ])
:inf-T-Field(Γ├ t0.fi : Ci, [Γ├ t0 : C0, fields(C0) = <C f>])
:inf-T-Invk(Γ├ t0.m(<t>) : C, [Γ├ t0 : C0, mtype(m\, C0) = <D> → C, Γ├ <t> : <C>, <C> <: <D>])
:inf-T-New(Γ├ new C(<t>) : C, [Γ├ <t> : <C>, <C> <: <D>])
:inf-T-UCast(Γ├ (C)t0 : C, [Γ├ t0 : D, D <: C])
:inf-T-DCase(Γ├ (C)t0 : C, [Γ├ t0 : D, C <: D, C != D])
:inf-T-SCast(Γ├ (C)t0 : C, [Γ├ t0 : D, C !<: D, D !<: C, 愚かさの警告])
:inf-T-Method(C0 m (<C x>) { return t0; } OK in C, [<x> : <C>\, this : C ├ t0 : E0, E0 <: C0, CT(C) = class C extends D { ... }, override(m\, D\, <C> → C0)])
:inf-T-Class(class C extends D { <C f;> K <M> } OK, [K = C(<D g>\, <C f>), { super(<g>); this.<f> = <f>; }, fields(D) = <D g>, <M> OK in C])
:e-box

\<b id="19.4.2">演習 19.4.2. </b>
FJ は Java のサブセットであるので、FJ プログラムは正しく型付けされているときのみ 正しく型付けされた Java プログラムになることが要求されている。
仮にこの要求を捨てて、単に Java 風の核となる計算体系が欲しいとき、設計をどのように考えるだろうか。

\<b id="19.4.3">演習 19.4.3. </b>
破壊的代入は計算体系の基本を大きく変えることなく追加せよ。13章の参照の扱い方を参考にするとよい。

\<b id="19.4.4">演習 19.4.4. </b>
14章の例外の扱い方を参考にして、Java の throw, try のようなもので FJ を拡張せよ。

\<b id="19.4.5">演習 19.4.5. </b>
完全な Java と同様、FJ では型付け関係をアルゴリズム的な形式で表現していて、包摂関係はない。今ある規則の代わりに、包摂規則を導入して型システムをより宣言的に形式化しなおせるだろうか。

\<b id="19.4.6">演習 19.4.6. </b>
Java のインターフェースはメソッドの型を指定するが、実装は持たない。また、extends と違い、任意の数のインターフェースを implements することができる。
型付け可能な項に対して最小の型を与えてくれる、
インターフェースと条件式（Java では t1 ? t2 : t3 と書く）の間の相互作用のため、型付け可能な項に対して最小の型を与えるような型付け関係のアルゴリズムが必要である。
(1) Java 流のインターフェースで FJ を拡張する方法を示せ
(2) インターフェースが存在するなら、部分型関係が結びの下で必ずしも閉じるとは限らないことを示せ。（結びの存在は、条件式の最小型付け性に重要な役割を果たす）
(3) 条件式に対する Java の型付け規則はどのようなものだろうか。それは妥当か。

\<b id="19.4.7">演習 19.4.7. </b>
FJ に super のキーワードを追加する方法を示せ。
:e

:sec 5
性質

:s

\<b id="19.5.1">定理 19.5.1. </b>[保存]
\<h>略</h>

\<b id="19.5.2">補題 19.5.2. </b> t が正しく型付けされた項だとする。
\<h>略</h>

\<b id="19.5.3">定義 19.5.3. </b> FJ の評価文脈の集合は以下のように定義される。
\<h>略</h>

\<b id="19.5.4">定理 19.5.4. </b>[進行]
\<h>略</h>

\<b id="19.5.5">演習 19.5.5. </b>
\<h>略</h>

\<b id="19.5.6">演習 19.5.6. </b>
\<h>略</h>


:e

:sec 6
オブジェクト表現 vs 組み込みのオブジェクト

:s

18章では、レコード、参照、ラムダ計算の機能を組み合わせて、オブジェクト、クラス、継承を表現した。
本章では、オブジェクトとクラスを組み込みとして持つ単純な言語を説明した。

この２つの対照的アプローチにはどちらも使い道がある。

オブジェクトの表現により、オブジェクトの仕組みがあらわになるため、低水準な言語にオブジェクトを翻訳するコンパイル方法を考える手助けになる。
組み込み機能としてのオブジェクトにより、操作的意味論や型付けの振る舞いを直接議論することができる。

究極的には、オブジェクトを組み込みで含む高水準な言語から、レコードと関数しか持たないような低水準な言語への変換を示し、その正当性を証明することが良いとされる。
:e

:sec 7
注記

:s

FJ の他の紹介
:e
