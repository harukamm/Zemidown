font-size 10

#

:ch 16
部分片付けのメタ理論

:sec 0
この章でやりたいこと

:s
:s-item
-\前章での「部分型付けのある単純型付きラムダ計算」の定義は、<b>構文主導</b>ではない
-構文主導とは、構文に基づいて、動作や意味が決まること
-ボトムアップでは型検査アルゴリズムは得られない
:e-item

:s-box
★ 何が問題点か

:s-item
-主な問題は、包摂規則(T-SUB)と推移律(S-TRANS)
-\単一のメタ変数 t を使って定義されているため、ほぼ任意の式に対して規則が適用可能になってしまう<br>=> どの規則を試すべきかが自明ではなく、アルゴリズムとしては不十分
-\さらに、S-TRANSには結論部に束縛されないメタ変数 U が前提部に出現する<br>=> 推測できる U の数は無限個あるため、このまま実装するには不適切
:e-item

:s-horizon
:inf-T-SUB(Γ├ t : T,[Γ├ t : S, S <: T])
:inf-S-TRANS(S <: T,[S <: U, U <: T])
:e-horizon
:e-box

これらの問題は既存の規則を、構文主導的な推論規則の集合からなる以下の２つの関係で置き換えれば、解決できる。
:s-itemn
-アルゴリズム的部分型関係
-アルゴリズム的型付け関係
:e-itemn
また、書き換え前後の表現が一致することを証明することにより、この書き換えの正しさを示す。

:e

:sec 1
アルゴリズム的部分型付け

:s
例えば、t1 が T→U 型をもち、t2 が S 型を持つとして、関数適用 t1 t2 に出会ったとき、「SはTの部分型か」を判断するために、部分型検査器アルゴリズムが呼び出される。

アルゴリズム的関係には、規則S-TRANS, S-REFLがない。
S-TRANSをなくすには、まず深さ・幅・並び替えの部分型付けを一つにまとめる規則を追加する必要がある。

:inf-S-RCD({ kj : Sj | j∈1..m } <: { li : Ti | i∈1..n },[{ li | i∈1..n } ⊆ { kj | j∈1..m }, kj = li ならば、Sj <: Ti])

> つまり..
レコードA{ kj : Sj }、レコードB{ li : Ti } について
:s-item
-レコードAのラベル名の集合が、レコードBのラベル名の集合を含んでる
-それぞれの同じラベル名 kj, li について Sj <: Ti
:e-item
ならば、レコードAはレコードBの部分型。

このS-RCDが、S-RCD-DEPTH, S-RCD-WIDTH, S-RCD-PERM（部分型付け規則の一部）を置き換えるものとして十分だということを、次の補題で証明してみよう。。

\<b id="16.1.1">補題 16.1.1</b>
\<!-- もし、S-RCD-DEPTHとS-RCD-WIDTHとS-RCD-PERMの規則を含む（しかしS-RCDは含まない）部分型付け規則で  S <: T が導出できるならば、これは規則S-RCDを使っても（S-RCD-DEPTHとS-RCD-WIDTHとS-RCD-PERMの規則は使わないで）導出できる。また、逆も同様である。 --> S-RCD-DEPTH + S-RCD-WIDTH + S-RCD-PERM を含む部分型付け規則で S <: T を導出できる
⇄ S-RCD で S <: T を導出できる

:inf-S-RCD-DEPTH({ li : Si | i∈1..n } <: { li : Ti | i∈1..n }, [各iに対して Si <: Ti])
:inf-S-RCD-WIDTH({ li : Ti | i∈1..n+k } <: { li : Ti | i∈1..n }, [])

:inf-S-RCD-PERM({ kj : Sj | j∈1..n } <: { li : Ti | i∈1..n }, [{ kj : Sj | j∈1..n } は { li : Ti | i∈1..n } の並び替えである])

⇅
:inf-S-RCD({ kj : Sj | j∈1..m } <: { li : Ti | i∈1..n },[{ li | i∈1..n } ⊆ { kj | j∈1..m }, kj = li ならば、Sj <: Ti])

:s-box
証明）
導出に関する帰納法により、示す。

(→) S <: T を導出する最後の規則で場合わけをする
:s-itemn
-\S-RCD-DEPTHの場合<br>S-RCD において、{ li } ≡ { kj } であるようなケース。{ li } ≡ { kj } より、前提部 { li } ⊆ { kj } を導くことができる。
-\S-RCD-WIDTHの場合<br>自明
-\S-RCD-PERMの場合<br>{ kj : Sj } が { li : Ti } の並び替えであるなら、前提部 { li } ⊆ { kj } を導くことができる。
:e-itemn

(←) S <: T を導出する最後の規則が S-RCDであるとして、
:s-item
{ a:{x:Nat y:Bool} b:Bool } <: { a:{y:Bool x:Nat} }
-\【{ li | i∈1..n } ⊆ { kj | j∈1..m } 】の部分<br>S-RCD-WIDTHに対応
-\【kj = li ならば、Sj <: Ti】の部分<br>ラベルの対応づけを行ってから型の対応関係を求めているので、S-RCD-PERM と S-RCD-DEPTH に対応
:e-item
の性質と、帰納法の仮定で示せれる。
:e-box

この証明によって、S-RCDが、S-RCD-DEPTH, S-RCD-WIDTH, S-RCD-PERM を置き換えるものとして十分だということが示せた。
\結果的に得られる型システムを、以下（<a href="#fig.16.1">図16-1</a>) のようにまとめることができる。

\<b id="fig.16.1">図16-1</b>: レコードのある部分型関係
:s-box
:s-horizon
:inf-S-REFL(S <: S, [])
:inf-S-TRANS(S <: T, [S <: U, U <: T])
:e-horizon
:s-horizon
:inf-S-TOP(S <: TOP, [])
:inf-S-ARROW(S1 → S2 <: T1 → T2, [T1 <: S1, S2 <: T2])
:e-horizon

:inf-S-RCD({ kj : Sj | j∈1..m } <: { li : Ti | i∈1..n },[{ li | i∈1..n } ⊆ { kj | j∈1..m }, kj = li ならば、Sj <: Ti])
:e-box

では、次にS-TRANS, S-REFLが別のアルゴリズム的関係に置き換えることができることを示そう。

\<b id="16.1.2">補題 16.1.2</b>
(1) すべての型Sについて、S <: S はS-REFLを使わずに導出できる
(2) もし S <: Tが導出可能ならば、 S <: T は S-TRANSを使わずに導出できる

:s-box
証明）
(1) 型の大きさに関する帰納法で示す。
:s-item
-\S ≡ Top の場合<br>Top <: Top は、S-TOPにより示せる
-\S ≡ T1 → T2 の場合<br>T1 → T2 <: T1 → T2 は、S-ARROW により T1 <: T1, T2 <: T2 が成り立てばよいが、<br>これは帰納法の仮定により成立する。
-\S ≡ { ki : Si ( i∈1..n ) } の場合<br>補題16.1.1(→)より、S-RCD-DEPTHはS-RCDで代用することができる。<br>これを適用すると、各iに対して Si <: Si が成り立てばよいことになるが、これは帰納法の仮定により成り立つ。<br>
:e-item

(2) 型の大きさに関する帰納法で示す。
S ≡ Top の場合
:s-item
-\T ≡ Top の場合<br>S-TOPにより成立。
-\T ≡ T1 → T2 の場合<br>そもそも導出不可能。(Topの定義より)
-\T ≡ { li : Si } の場合<br>そもそも導出不可能。(Topの定義より)
:e-item

S ≡ S1 → S2 の場合
:s-item
-\T ≡ Top の場合<br>S-TOPにより成立。
-\T ≡ T1 → T2 の場合<br>S-ARROWにより、T1 <: S1, S2 <: T2 が成り立てばよい。あとは帰納法の仮定。
-\T ≡ { li : Ti } の場合<br>そもそも導出不可能。※1
:e-item

S ≡ { kj : Sj } の場合
:s-item
-\T ≡ Top の場合<br>S-TOPにより成立。
-\T ≡ T1 → T2 の場合<br>そもそも導出不可能。※1
-\T ≡ { li : Ti } の場合<br>S <: T は導出可能なので、補題15.3.2(2)'より、<br>{ li } ⊆ { kj } かつ li = kj では Sj <: Ti である。つまり、S-RCDを適用すればおk。
:e-item

※1 補題15.3.2(2)を再証明することにより
:e-box


\よって、アルゴリズム的部分型付けは以下 (<a href="#fig.16.2">図16-2</a>) のようにまとめることができる。
※ 本章では、前章で扱った部分型付け判断式 S <: T の代わりに、|→ S <: T (「Sはアルゴリズム的にTの部分型になる」)という別の関係として表記する。
\<b id="fig.16.2">図16-2</b>: アルゴリズム的部分型付け
:s-box
:inf-SA-TOP(|→ S <: TOP, [])

:inf-SA-ARROW(|→ S1 → S2 <: T1 → T2, [ |→ T1 <: S1, |→ S2 <: T2])

:inf-SA-RCD(|→ { kj : Sj | j∈1..m } <: { li : Ti | i∈1..n },[{ li | i∈1..n } ⊆ { kj | j∈1..m }, kj = li ならば、|→ Sj <: Ti])
:e-box


\<b id="16.1.3">演習 16.1.3</b>
もし、型Boolを追加したら、これらの性質はどう変化するだろうか。

:s-box
証明）
型Boolを追加すると、型の構文規則が以下のようになる。

:s-table
|T|::=|Top|
| |   |T → T|
| |   |{ li : Ti ( i∈1..n ) }|
| |   |\<b>Bool</b>|
:e-table

ベースとなる型がひとつ増えるわけなので、以下のような規則を追加する必要がでてくる。
:inf-SA-BOOL(|→ Bool <: Bool, [])
:e-box


\<b id="16.1.4">定義 16.1.4</b>
\アルゴリズム的部分型関係は、<a href="#fig.16.2">図16-2</a>の規則に閉じた最小の関係である。

:s-box
:s-item
-\<b>健全性</b> アルゴリズム的規則で導出できるすべての部分型付け判断式は、宣言的規則でも導出できる
-\<b>完全性</b> 宣言的規則で導出できる全ての部分型付け判断式がアルゴリズム的規則でも導出できる
:e-item
:e-box


\<b id="16.1.5">命題 16.1.5</b>
[健全性と完全性] S <: T のとき、かつそのときのみ |→ S <: T

:s-box
証明）
どちらも導出に関する帰納法で示す。
(→)
S <: T 導出木で、最後に適用した規則で場合分けする。
:s-item
-\S-REFL の場合<br>先の補題と導出の大きさに関する帰納法の仮定より。
-\S-TRANS の場合<br>先の補題と導出の大きさに関する帰納法の仮定より。
-\S-TOP の場合<br>SA-TOPを適用すればよい。
-\S-ARROW の場合<br>導出の大きさに関する帰納法の仮定より、|→ T1 <: S1, |→ S2 <: T2 が成り立つので、これに SA-ARROWを適用すればよい。
-\S-RCD の場合<br>略
:e-item

(←) 
略
:e-box


これで、アルゴリズム的部分型関係を検査するアルゴリズムが完成した＾＾
このアルゴリズムを擬似コードとして書くと以下のようになる。

:s-box
:s-table
|subtype(S, T)|=|if T = Top then true|
|             | |else if S = S1 → S2 and T = T1 → T2|
|             | |\&nbsp;&nbsp;then subtype(T1, S1) ^ subtype(S2, T2)|
|             | |else if S = { kj : Sj \| j∈1..m } and T = { li : Ti \| i∈1..n }|
|             | |\&nbsp;&nbsp;then { li \| i∈1..m } ⊆ { kj \| j∈1..m }|
|             | |\&nbsp;&nbsp;&nbsp;&nbsp;^ すべてのiに対して、j∈1...mが存在し、kj = li かつ subtype(Sj, Ti)|
|             | |else false|
:e-table
:e-box

\最後に、この関係が<b>全域的</b>、つまり、この再帰関数subtypeが任意の入力に対して有限時間内に結果を返すことを検証する必要がある。

\<b id="16.1.6">命題 16.1.6</b>
[停止性] もし |→ S <: T が導出可能ならば、subtype(S, T)は true を返す。そうでないなら、false を返す。

:s-box
証明）
再帰時の引数の大きさの和は、入力S, Tの大きさの和より真に小さいので、ちゃんと止まる。
:e-box


【「はじめっから、アルゴリズム的定義でやれば良いのでは？」と思った人へ】
まあその通りなのだが、型付け関係の正当性を示すためには、「部分型付けが反射的・推移的である」ことを知る必要があるので、どっちの定義を先に持ってきても作業量はさほど変わらないよ。

:e

:sec 2
アルゴリズム的型付け

:s
部分型関係をアルゴリズム的にした今、型付け関係もアルゴリズム的にする必要がある。現在、T-SUBだけが構文主導でない型付け規則であるが、これをなくすことを考えてみよう。

:inf-T-SUB(Γ├ t : T,[Γ├ t : S, S <: T])

\簡単にT-SUBを消すことはできない。T-SUBを使う目的は「関数によって期待される型と、引数の実際の型との隔たりを埋めること」である。下の例は、T-SUBが型付けにおいて重要な役割を果たす<b>唯一の</b>状況である。

(λr:{ x:Nat }. r.x) { x=0, y=0 }

他の全ての場合では、部分型付け判断式を別の導出によって証明することができる。T-SUBを木の根に向かって動かし「後回し」にする導出である。このテクニックをここで少し紹介する。
\<h3>略</h3>

\<b id="16.2.1">演習 16.2.1</b>
この実験を仕上げるため、T-RCD または T-PROJ の前で規則T-SUBが使われているような導出において、どのように同様の再配置を実行すればよいかを示せ。

:s-box
証明）
省略
:e-box

さて、このことからT-SUBが必要となる場所はただ一つ、関数適用だけになった。この場合にT-SUBなしで対応するために、関数適用の規則を少し強力なもので置き換えてみよう。

:inf(Γ├ t1 t2 : T12, [Γ├ t1 : T11 → T12, Γ├ t2: T2, T2 <: T11])

↑前提部にT-SUBのインスタンスの一つ「T2 <: T11」を合体させた！これにより、全ての導出がT-SUBを使わない形になり、元の型システムと同じ項の集まりに型を割り当てる【構文主導的な型付け規則の集合】が得られた（＾ー＾）b

\よって、アルゴリズム的型付けは以下 (<a href="#fig.16.3">図16-3</a>) のようにまとめることができる。
※アルゴリズム的部分型付け規則と同様、宣言的関係と区別するため、Γ|→ t : T と書くことにする。
\<b id="fig.16.3">図16-3</b>: アルゴリズム的型付け
:s-box
:s-horizon
:inf-TA-VAR(Γ|→ x : T, [x : T ∈ Γ])
:inf-TA-ABS(Γ|→ λx:T1. t2 : T1 → T2,[Γ、x : T1 |→ t2 : T2])
:e-horizon

:inf-TA-APP(Γ|→ t1 t2 : T12, [Γ|→ t1 : T1, Γ|→ t2: T2, T1 = T11 → T12, |→ T2 <: T11])

:inf-TA-RCD(Γ|→ { l1=t1 ... ln=tn } : { l1 : T1 ... ln : Tn }, [各iに対して、Γ|→ ti : Ti])

:inf-TA-PROJ(Γ|→ t1.li : Ti, [t1 : R1, R1 = { l1 : T1 ... ln : Tn }])

:e-box


\<b id="16.2.2">定義 16.2.2</b>
\アルゴリズム的型付け関係は<a href="#fig.16.3">図16-3</a>の規則について閉じた最小の関係である。

\<b id="16.2.3">演習 16.2.3</b>
ある項にアルゴリズム的型付け規則で割り当てられる型が評価によって、減少しうることを示せ。これは、ある２つの項 s と t で、アルゴリズム的型付けで S と T に型付けされ、s →* t かつ T <: S だが、S !<: T となるようなものを見つけることで示せ。

:s-box
証明）
:s-item
-しらん
:e-item
:e-box


部分型付けのときと同様に、アルゴリズム的型付け関係が、元の宣言的な規則について、健全かつ完全であることを証明していく。

\<b  id="16.2.4">定理 16.2.4</b>
[健全性] Γ|→ t : T ならば Γ├ t : T となる。
アルゴリズム的型付け導出に関する単純な帰納法により、示せ。

:s-box
証明）
省略
:e-box


\<b id="16.2.5">定理 16.2.5</b>
[完全性、最小型付け] もし Γ├ t : T ならば、ある S <: T が存在して、Γ|→ t : S

:s-box
証明）
宣言的な型付け導出に関する帰納法により証明。
:s-item
-\T-VAR の場合 t = x <br>このとき、Γ(x) = T これに TA-VARを適用すれば、Γ|→ x : T<br><br>
-\T-ABS の場合 t =  λx:T1. t2<br>このとき、Γ, x : T1├ t2 : T2 かつ T = T1 → T2<br>帰納法の仮定より、ある S2 <: T2 に対し、Γ, x : T1├ t2 : S2<br>これにTA-ABSを適用すると、Γ├t : T1 → S2<br>S-ARROWより、T1 → S2 <: T1 → T2<br><br>
-\T-APP の場合 t = t1 t2<br>このとき、Γ├t1 : T11 → T12 かつ Γ├t2 : T11 かつ T = T12<br>帰納法の仮定より、ある S1 <: T11 → T12 に対し、Γ |→ t1 : S1 であり、ある S2 <: T11 に対し、Γ├t2 : S2 である。<br>補題15.3.2より、S1 は T11 <: S11 かつ S12 <: T12 なる S11 と S12 に対して S11 →S12 という形をもつ。<br>S-TRANSより、S2 <: S11。アルゴリズム的部分型付けの完全性より、|→ S2 <: S11<br>さらに TA-APP より、Γ├t1 t2 : S12<br><br>
-\T-RCD の場合 t = { li=ti }<br>このとき、各iに対し Γ├ti : Ti かつ T = { li:Ti }。あとは帰納法の仮定とTA-RCDより。<br><br>
-\T-APROJ の場合 t = t1.lj<br>このとき、Γ├ t1 : { li:Ti } かつ T = Tj。あとは略<br><br>
-\T-SUB の場合 前提条件より、t : S' かつ S' <: T<br>帰納法の仮定より、ある S <: S' が存在して、Γ├ t : S であるが、このときS-TRANSより、S <: T。
:e-item
:e-box


\<b id="16.2.6">定理 16.2.6</b>
もし部分型付け規則 S-ARROW をなくし、それ以外の宣言的な部分型付け規則、および型付け規則はそのままにした場合、この体型は最小型付けの性質を持つか。もしそうならば、それを証明せよ。そうでないなら、最小型を持たない、型付け可能な項の例を示せ。

:s-box
証明）
項 λx: {a : Nat}. x は宣言的な規則の下では、
:s-item
-{a:Nat} → {a:Nat}
-{a:Nat} → Top
:e-item
のどちらの型ももつ。

しかし、S-ARROWをなくすと、これらの型は互いの部分型にならない。
つまり、下式を証明できなくなる。

{a:Nat} → {a:Nat} <: {a:Nat} → Top
:e-box


:e

:sec 3
結びと交わり

:s
分岐があると、部分型の扱いが少しややこしくなる。なぜなら、どの場合に分岐しても必ず部分的に同じ型でなくてはいけなくなるから。
例えば、以下のような導出規則T-IFがあるとする。

:inf-T-IF(Γ├ if t1 then t2 else t3 : T, [Γ├ t1 : Bool, Γ├ t2 : T, Γ├ t3 : T])

このとき、if true then { x=true, y=false} else { x=false, z=true } は { x: Bool } という型をもつ。
なぜなら、
:s-item
-then節は最小型 { x: Bool, y: Bool } を持ち、これはT-SUBによって { x: Bool } に昇格できる
-else節の型 { x: Bool, z: Bool } も { x: Bool } に昇格できる
-よって、{ x: Bool, y: Bool } と { x: Bool, z: Bool } の両方の上位型である任意の型をもつ
-この中で最小の型は { x: Bool }　である
:e-item
ためである。

\この型は分岐の型についての<b>結び</b>としばしば呼ばれる。これは半順序における２つの要素の結びに相当するからである。

\<b id="16.3.1">定義 16.3.1</b>
:s-item
-\[<b>結び</b>] 型の二つ組S, Tに対して、ある型 J が S と T の<b>結び</b>であるとは、S <: J かつ T <: J かつ 任意の型 U に対して、S <: U かつ T <: U ならば J <: U となること。
-\[<b>交わり</b>] 型の二つ組S, Tに対して、ある型 M が S と T の<b>交わり</b>であるとは、M <: S かつ M <: T かつ、任意の型 L に対して、L <: S かつ L <: T ならば、L <: M となること。
-\[<b>下に有界</b>] 型の二つ組S, Tについて、ある型 L が存在して、L <: S かつ L <: T となるとき、<b>下に有界である</b>という。
-\[<b>有界な交わり</b>] 下に有界である全ての S と T について、S と T の交わり M が存在するような部分型関係は、<b>有界な交わりを持つ</b>という。
:e-item

\<img src="./graph.png" width="600px">

注釈
:s-item
-結びの関係を、S v T = J と表記する。
-交わりの関係を、S ^ T = M と表記する。
:e-item

この節で考える部分型関係は結び (最大でTop) を持つが交わりを持たない。
例えば、型 {} と Top → Top は共通の部分型を全く持たないため、最大の共通の部分型は存在しない。

結びや交わりは唯一である必要はない。
例えば、{ x : Top, y : Top, z : Top } と { x : Top, y : Top, w : Top } は、結びとして、{ x : Top, y : Top } と { y : Top, x : Top } を持つ。

同じ型の二つ組に対する、二つの異なる結び J1, J2（または交わり）は必ず、お互いの部分型になる。

\<b id="16.3.2">命題 16.3.2</b>
(1) すべての型の二つ組S, Tについて、ある型Jが存在して、S v T = J
(2) 共通の部分型を持つ、すべての型の二つ組S, Tについて、ある型Mが存在して、S ^ T = M

:s-box
証明）
どちらの場合も、それを求めるアルゴリズムを示せればよい。
:s-table
|S v T = | Bool               | S = T = Bool の場合|
|        | M1 → M2            | S = S1 → S2,|
|        |                    | T = T1 → T2,|
|        |                    | S1 ^ T1 = M1,|
|        |                    | S2 v T2 = J2 の場合|
|        | { jl:Jl \| l∈1..q }| S = { kj:Sj \| j∈1..m }|
|        |                    | T = { li:Ti \| i∈1..n }|
|        |                    | { jl \| l∈1..q } = { kj \| j∈1..m } ∩ { li \| i∈1..n }|
|        |                    | 各 jl = kj = li に対して Sj v Ti = Jl の場合|
|        | Top                | それ以外|
:e-table
:s-table
|S ^ T = |省略|
:e-table
:e-box


\<b id="16.3.3">演習 16.3.3</b>
if true then false else {} の最小型は何か。これは我々の求めているものか。

:s-box
証明）
:s-item
-then節は最小型として Bool を持つ
-else節は最小型として {} を持つ
-両節の上位型の中で最小の型はTop
-よって、全体として Top 型になる
:e-item
任意の型Sに対して S <: TOP が成り立つ(SA-TOP)ので、あまり情報として意味がない。
:e-box


\<b id="16.3.4">演習 16.3.4</b>
結びと交わりを計算するアルゴリズムを、15.5節で記述されたような参照を持つ手続き型言語へ拡張することは簡単か。非変なRefを共変なSourceと反変なSinkに詳細化した15.5節での参照の扱いについてはどうか。
:inf-S-SOURCE(Source S1 <: Source T1, [S1 <: T1])
:inf-S-SINK(Sink S1 <: Sink T1, [T1 <: S1])

:s-box
証明）
Ref の追加に関しては、アルゴリズムを拡張するだけでよい(省略)。
しかし、Source, Sink 構築子に詳細化すると、部分型関係が結び・交わりを持たなくなる問題が発生する。
例えば、
:s-item
-Ref { a:Nat b:Bool } <: Source { a: Nat }
-Ref { a:Nat } <: Sink { a:Nat b:Bool }
:e-item
であるが、これらは共通の下界を持たない。(Refは非変であるため)
この問題を回避するためにはSource, Sinkを両方でなく、どちらか一方だけを導入すること。これらの具体的な実装については、後の章でやる予定。
:e-box


:e

:sec 4
アルゴリズム的型付けとBottom型

:s
もし部分型関係に最小型Bot(15.4節)を加える場合、拡張が必要。
まず、アルゴリズム的部分関係に一つの公理を追加する。
:inf-SA-BOT(|→ Bot <: T, [])

次に、アルゴリズム的型付け関係には、二つの規則を追加する。

:inf-TA-APPBOT(Γ|→ t1 t2 : Bot, [Γ|→ t1 : T1, T1 = Bot, Γ|→ t2 : T2])
:inf-TA-PROJBOT(Γ|→ t1.li : Bot, [Γ|→ t1 : R1, R1 = Bot])

Botは任意の他の型を持つことができる。

Bot型のものには無条件に任意の型の引数を関数適用できる。
これはT-SUBを使って、Botをどんな関数型にもできるため。射影(TA-PROJBOT)に関しても同様。

\<b id="16.4.1">演習 16.4.1</b>
この言語が条件式も持っていたとする。このとき、ifについてのアルゴリズム的型付け規則を追加する必要はあるか。

:s-box
証明）
追加の必要あり。
:inf-TA-IF(Γ|→ if t1 then t2 else t3 : T, [Γ|→ t1 : T1, T1 = Bot, Γ|→ t2 : T2, Γ|→ t3 : T3, T2 v T3 = T])
など。
Bot は空なため（実際にBot型となるような項は存在しない）、t1 の評価は結果を返すことはない。
:e-box


28.8節で、Botが有界量化と合わさったときにより複雑になるが、今節でのBotの追加は容易い。
:e
